# -*- coding: utf-8 -*-
"""Copy of Waterpoints.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uQqIZsnvG9DzBLi8ImvzjQ-NLwygf7iw
"""

# import libraries
import urllib
from urllib.request import urlopen
import json
import pandas as pd
import numpy as np

# url input function
# this is the url for simplicity : https://raw.githubusercontent.com/onaio/ona-tech/master/data/water_points.json
url = input("Enter the data URL: ")
print('Data URL =',url)

# Storing the data
response = urlopen(url)


# storing the JSON response 
# from url in data
data_json = json.loads(response.read())

#create a pandas dataframe
df = pd.DataFrame (data_json)
df.head(5)
df.shape
#checking df information whether there are empty columns and also the datatypes available in the dataset

#selecting a subset from the dataframe (df) where we only need column 10, column 26
relevant_columns = df[['communities_villages', 'water_functioning']]
#create a new dataframe for the data subsets i.e only the relevant columns
#now we are only going to work with this dataframe, we called it relevant_columnsDF
relevant_columnsDf= pd.DataFrame (relevant_columns)
#Converting the unordered categorical 'Water functioning' , 
#converted the (if functioning is 'yes' replaced it with '1' and if  functioning is 'no' replaced it with '0')
#this is to further check for any data disparencies

relevant_columnsDf.water_functioning =relevant_columnsDf.water_functioning.map({'yes':'1','no':'0'})

print( 'we will be working with this two columns and hence created a dataset called  relevant_columns  if value is 1 then  its functioning \n if the value is 0 then it is not functioning  \n  \n :', relevant_columnsDf )

#checking if our water_functioning column has any empty or irrelevant /dirty data.
#converting data to categorical helped us identify that there are two elements that are not of type 1 or 0 
relevant_columnsDf['water_functioning' ].value_counts(dropna=False )

# if water functioning contains a value which is neither 'yes' nor 'no' it eliminates it.
#we eliminated the NAN 
relevant_columnsDf.dropna(subset = ["water_functioning"], inplace=True)

#clean data
relevant_columnsDf['water_functioning' ].value_counts(dropna=False )

#Each community village and it's total numbe of water points.
relevant_columnsDf['communities_villages' ].value_counts(dropna=False )

#visualize the waterpoints which are working and those which are not working.
import seaborn as sns
sns.countplot(relevant_columnsDf['water_functioning'])

#look at all the values in each column and get a count using (for val which loops through the entire dataframe)
#the number of occurences per village whichmeans the number of water points per village either functional or unfunctional.
#the number of either fuctioning or unfuctioning water points 
#for val in relevant_columnsDf:
  #  print(relevant_columnsDf[val].value_counts())
#print()

#the output of this cell could further help us deduce that there are 65 communities_villages
CommunityNumberDf= relevant_columnsDf['communities_villages' ].value_counts(dropna=False )
print('the number of villages are equal to \n:', len(CommunityNumberDf) )

#Checking for the total functioning and unfuctioning data points where 1 is yes and 0 is no
#the output shows that there are 623 working points and 87 points which are not working.
relevant_columnsDf['water_functioning' ].value_counts(dropna=False )
workingWaterPointsDf= relevant_columnsDf.loc[relevant_columnsDf['water_functioning' ]=='1']
print ('The number of working water points which are functioning  is \n :' , len(workingWaterPointsDf))
# selecting rows based on condition , this codes selects all rows with a value zero which represents "no" meaning not fuctional.
#Then stores them in a NotFunctional dataframe.
notFunctionalWaterPointsDf = relevant_columnsDf.loc[relevant_columnsDf['water_functioning'] == '0'] 
    
print('\nResult dataframe for water points that are not functioning :\n', 
 len(notFunctionalWaterPointsDf)     )
percentagesDf= notFunctionalWaterPointsDf['communities_villages'].value_counts(normalize=True)*100
print ('percentage of broken water points in rank from highest to lowest is : \n' ,  percentagesDf)

